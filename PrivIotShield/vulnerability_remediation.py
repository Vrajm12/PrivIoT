import json
import logging
import os
import re
import socket
import ssl
import time
from datetime import datetime

import requests
from requests.exceptions import RequestException

logger = logging.getLogger(__name__)

class RemediationEngine:
    """
    Enterprise-grade remediation engine for IoT device vulnerabilities.
    
    This class provides automated remediation capabilities for various types of
    IoT device vulnerabilities, including firmware updates, configuration changes,
    and security hardening measures.
    """
    
    def __init__(self):
        """Initialize the remediation engine"""
        self.results = {}
        
    def remediate(self, vulnerability, device):
        """
        Main remediation orchestration method
        
        Args:
            vulnerability (dict): Vulnerability information
            device (dict): Device information
            
        Returns:
            dict: Remediation results
        """
        logger.info(f"Starting remediation for vulnerability ID {vulnerability.get('id')} on device {device.get('name')}")
        
        vuln_type = vulnerability.get('type', 'unknown').lower()
        
        # Reset results
        self.results = {
            'vulnerability_id': vulnerability.get('id'),
            'device_id': device.get('id'),
            'success': False,
            'message': None,
            'steps_performed': [],
            'timestamp': datetime.utcnow().isoformat(),
            'manual_steps': vulnerability.get('manual_steps', [])
        }
        
        try:
            # Select remediation strategy based on vulnerability type
            if 'default_credentials' in vuln_type or 'weak_password' in vuln_type:
                self._remediate_credentials(vulnerability, device)
            elif 'firmware' in vuln_type or 'outdated' in vuln_type:
                self._remediate_firmware(vulnerability, device)
            elif 'open_port' in vuln_type or 'unnecessary_service' in vuln_type:
                self._remediate_open_ports(vulnerability, device)
            elif 'encryption' in vuln_type or 'ssl' in vuln_type or 'tls' in vuln_type:
                self._remediate_encryption(vulnerability, device)
            elif 'http' in vuln_type or 'https' in vuln_type:
                self._remediate_insecure_http(vulnerability, device)
            elif 'auth' in vuln_type or 'permission' in vuln_type:
                self._remediate_authentication(vulnerability, device)
            elif 'wifi' in vuln_type or 'wireless' in vuln_type:
                self._remediate_wifi_security(vulnerability, device)
            else:
                # Generic remediation for other vulnerability types
                self._remediate_generic(vulnerability, device)
        
        except Exception as e:
            logger.error(f"Remediation error: {str(e)}")
            self.results['success'] = False
            self.results['message'] = f"Remediation failed: {str(e)}"
            
        # Add timestamp
        self.results['completed_at'] = datetime.utcnow().isoformat()
        
        logger.info(f"Remediation completed for vulnerability {vulnerability.get('id')} with success={self.results['success']}")
        return self.results
    
    def _device_connection_test(self, device):
        """Test if we can establish connection to the device"""
        try:
            ip_address = device.get('ip_address')
            if not ip_address:
                return False, "No IP address available for the device"
                
            # Try to connect to a common port
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5)  # 5 second timeout
            result = s.connect_ex((ip_address, 80))
            s.close()
            
            if result == 0:
                return True, "Connection successful"
            else:
                return False, f"Cannot connect to device (error code: {result})"
                
        except Exception as e:
            return False, f"Connection test failed: {str(e)}"
    
    def _remediate_credentials(self, vulnerability, device):
        """Remediate default or weak credential vulnerabilities"""
        ip_address = device.get('ip_address')
        if not ip_address:
            self.results['success'] = False
            self.results['message'] = "Cannot remediate: No IP address available for the device"
            return
            
        self.results['steps_performed'].append("Testing device connectivity")
        
        # Test connection
        connected, message = self._device_connection_test(device)
        if not connected:
            self.results['success'] = False
            self.results['message'] = f"Cannot establish connection to the device: {message}"
            return
            
        # In a real implementation, we would use device-specific APIs or protocols
        # to change passwords. For simulation, we'll use a mock API request.
        try:
            self.results['steps_performed'].append("Attempting to update device credentials")
            
            # Generate a strong password
            new_password = self._generate_strong_password()
            
            # Simulate API request to change password
            # In production, this would use actual device-specific authentication and APIs
            url = f"http://{ip_address}/api/settings/credentials"
            headers = {'Content-Type': 'application/json'}
            payload = {
                'username': 'admin',
                'old_password': 'admin',  # Assuming default password
                'new_password': new_password,
                'confirm_password': new_password
            }
            
            # Simulated request
            self.results['success'] = False  # Simulate failure for demo
            self.results['message'] = "Unable to authenticate with the device to change credentials. Please use manual remediation steps."
            
        except Exception as e:
            self.results['success'] = False
            self.results['message'] = f"Credential remediation failed: {str(e)}"
    
    def _remediate_firmware(self, vulnerability, device):
        """Remediate outdated firmware vulnerabilities"""
        ip_address = device.get('ip_address')
        if not ip_address:
            self.results['success'] = False
            self.results['message'] = "Cannot remediate: No IP address available for the device"
            return
            
        # Test connection
        connected, message = self._device_connection_test(device)
        if not connected:
            self.results['success'] = False
            self.results['message'] = f"Cannot establish connection to the device: {message}"
            return
            
        try:
            self.results['steps_performed'].append("Identifying available firmware updates")
            
            # In a real implementation, we would:
            # 1. Query manufacturer's API for latest firmware
            # 2. Download the firmware
            # 3. Upload and apply the firmware to the device
            
            # Simulate firmware update
            device_type = device.get('device_type', '').lower()
            manufacturer = device.get('manufacturer', '').lower()
            
            self.results['steps_performed'].append("Downloading latest firmware")
            time.sleep(1)  # Simulate download time
            
            self.results['steps_performed'].append("Uploading firmware to device")
            time.sleep(1)  # Simulate upload time
            
            self.results['steps_performed'].append("Initiating firmware installation")
            
            # Simulate firmware update failure
            self.results['success'] = False
            self.results['message'] = "Firmware update failed: Device rejected the firmware package or connection was interrupted"
            
        except Exception as e:
            self.results['success'] = False
            self.results['message'] = f"Firmware update failed: {str(e)}"
    
    def _remediate_open_ports(self, vulnerability, device):
        """Remediate unnecessary open ports or services"""
        ip_address = device.get('ip_address')
        if not ip_address:
            self.results['success'] = False
            self.results['message'] = "Cannot remediate: No IP address available for the device"
            return
            
        # Test connection
        connected, message = self._device_connection_test(device)
        if not connected:
            self.results['success'] = False
            self.results['message'] = f"Cannot establish connection to the device: {message}"
            return
            
        try:
            self.results['steps_performed'].append("Identifying unnecessary open ports and services")
            
            # Identify ports to close from vulnerability description
            ports_to_close = []
            description = vulnerability.get('description', '')
            
            # Extract port numbers from description
            port_matches = re.findall(r'(\d+)/(\w+)', description)
            if port_matches:
                ports_to_close = [(int(port), service) for port, service in port_matches]
            
            if not ports_to_close:
                self.results['success'] = False
                self.results['message'] = "Could not identify specific ports to close from vulnerability information"
                return
                
            self.results['steps_performed'].append(f"Attempting to close unnecessary ports: {', '.join([f'{p[0]}/{p[1]}' for p in ports_to_close])}")
            
            # In a real implementation, we would use device APIs to disable services
            
            # Simulate port/service closure failure
            self.results['success'] = False
            self.results['message'] = "Could not disable services remotely. Please follow the manual remediation steps."
            
        except Exception as e:
            self.results['success'] = False
            self.results['message'] = f"Port remediation failed: {str(e)}"
    
    def _remediate_encryption(self, vulnerability, device):
        """Remediate encryption-related vulnerabilities"""
        ip_address = device.get('ip_address')
        if not ip_address:
            self.results['success'] = False
            self.results['message'] = "Cannot remediate: No IP address available for the device"
            return
            
        # Test connection
        connected, message = self._device_connection_test(device)
        if not connected:
            self.results['success'] = False
            self.results['message'] = f"Cannot establish connection to the device: {message}"
            return
            
        try:
            self.results['steps_performed'].append("Analyzing current encryption settings")
            
            # In a real implementation, we would analyze and upgrade the encryption settings
            
            # Simulate SSL/TLS upgrade
            self.results['steps_performed'].append("Attempting to upgrade TLS configuration")
            
            # Simulate encryption upgrade failure
            self.results['success'] = False
            self.results['message'] = "Unable to upgrade encryption settings automatically. Please follow the manual remediation steps."
            
        except Exception as e:
            self.results['success'] = False
            self.results['message'] = f"Encryption remediation failed: {str(e)}"
    
    def _remediate_insecure_http(self, vulnerability, device):
        """Remediate insecure HTTP vulnerabilities"""
        ip_address = device.get('ip_address')
        if not ip_address:
            self.results['success'] = False
            self.results['message'] = "Cannot remediate: No IP address available for the device"
            return
            
        # Test connection
        connected, message = self._device_connection_test(device)
        if not connected:
            self.results['success'] = False
            self.results['message'] = f"Cannot establish connection to the device: {message}"
            return
            
        try:
            self.results['steps_performed'].append("Checking HTTP/HTTPS configuration")
            
            # In a real implementation, we would:
            # 1. Connect to the device admin interface
            # 2. Navigate to web server settings
            # 3. Enable HTTPS and disable HTTP
            
            # Simulate HTTPS configuration
            self.results['steps_performed'].append("Attempting to enable HTTPS and disable HTTP")
            
            # Simulate HTTP remediation failure
            self.results['success'] = False
            self.results['message'] = "Could not modify HTTP/HTTPS settings remotely. Please follow the manual remediation steps."
            
        except Exception as e:
            self.results['success'] = False
            self.results['message'] = f"HTTP/HTTPS remediation failed: {str(e)}"
    
    def _remediate_authentication(self, vulnerability, device):
        """Remediate authentication and permission vulnerabilities"""
        ip_address = device.get('ip_address')
        if not ip_address:
            self.results['success'] = False
            self.results['message'] = "Cannot remediate: No IP address available for the device"
            return
            
        # Test connection
        connected, message = self._device_connection_test(device)
        if not connected:
            self.results['success'] = False
            self.results['message'] = f"Cannot establish connection to the device: {message}"
            return
            
        try:
            self.results['steps_performed'].append("Analyzing authentication mechanisms")
            
            # In a real implementation, we would enhance authentication settings
            
            # Simulate authentication enhancement
            self.results['steps_performed'].append("Attempting to enhance authentication security")
            
            # Simulate authentication remediation failure
            self.results['success'] = False
            self.results['message'] = "Could not modify authentication settings remotely. Please follow the manual remediation steps."
            
        except Exception as e:
            self.results['success'] = False
            self.results['message'] = f"Authentication remediation failed: {str(e)}"
    
    def _remediate_wifi_security(self, vulnerability, device):
        """Remediate WiFi security vulnerabilities"""
        ip_address = device.get('ip_address')
        if not ip_address:
            self.results['success'] = False
            self.results['message'] = "Cannot remediate: No IP address available for the device"
            return
            
        # Test connection
        connected, message = self._device_connection_test(device)
        if not connected:
            self.results['success'] = False
            self.results['message'] = f"Cannot establish connection to the device: {message}"
            return
            
        try:
            self.results['steps_performed'].append("Analyzing WiFi security configuration")
            
            # In a real implementation, we would upgrade WiFi security settings
            
            # Simulate WiFi security enhancement
            self.results['steps_performed'].append("Attempting to enhance WiFi security")
            
            # Simulate WiFi security remediation failure
            self.results['success'] = False
            self.results['message'] = "Could not modify WiFi security settings remotely. Please follow the manual remediation steps."
            
        except Exception as e:
            self.results['success'] = False
            self.results['message'] = f"WiFi security remediation failed: {str(e)}"
    
    def _remediate_generic(self, vulnerability, device):
        """Generic remediation for other vulnerability types"""
        ip_address = device.get('ip_address')
        if not ip_address:
            self.results['success'] = False
            self.results['message'] = "Cannot remediate: No IP address available for the device"
            return
            
        # Test connection
        connected, message = self._device_connection_test(device)
        if not connected:
            self.results['success'] = False
            self.results['message'] = f"Cannot establish connection to the device: {message}"
            return
            
        try:
            # For generic vulnerabilities, provide detailed manual steps
            self.results['success'] = False
            self.results['message'] = "This vulnerability type requires manual remediation. Please follow the provided steps."
            
        except Exception as e:
            self.results['success'] = False
            self.results['message'] = f"Remediation failed: {str(e)}"
    
    def _generate_strong_password(self, length=16):
        """Generate a strong random password"""
        import random
        import string
        
        # Character sets
        lowercase = string.ascii_lowercase
        uppercase = string.ascii_uppercase
        digits = string.digits
        special = "!@#$%^&*()-_=+[]{}|;:,.<>?"
        
        # Ensure at least one character from each set
        password = [
            random.choice(lowercase),
            random.choice(uppercase),
            random.choice(digits),
            random.choice(special)
        ]
        
        # Fill the rest of the password
        for i in range(length - 4):
            password.append(random.choice(lowercase + uppercase + digits + special))
            
        # Shuffle the password
        random.shuffle(password)
        
        # Convert list to string
        return ''.join(password)


class VulnerabilityRemediator:
    """
    Main class for vulnerability remediation orchestration.
    This class coordinates the remediation process and tracks remediation history.
    """
    
    def __init__(self):
        """Initialize the vulnerability remediator"""
        self.engine = RemediationEngine()
        
    def remediate_vulnerability(self, vulnerability, device):
        """
        Remediate a vulnerability on a device
        
        Args:
            vulnerability (dict): Vulnerability information
            device (dict): Device information
            
        Returns:
            dict: Remediation results
        """
        # Log the remediation attempt
        logger.info(f"Remediating vulnerability {vulnerability.get('id')} on device {device.get('name')}")
        
        # Start remediation
        results = self.engine.remediate(vulnerability, device)
        
        # In a production system, we would update the vulnerability status in the database
        
        return results
    
    def batch_remediate(self, vulnerabilities, devices):
        """
        Remediate multiple vulnerabilities across multiple devices
        
        Args:
            vulnerabilities (list): List of vulnerability objects
            devices (dict): Dictionary of device objects by ID
            
        Returns:
            dict: Batch remediation results
        """
        results = {
            'total': len(vulnerabilities),
            'successful': 0,
            'failed': 0,
            'skipped': 0,
            'details': []
        }
        
        for vuln in vulnerabilities:
            device_id = vuln.get('device_id')
            if not device_id or device_id not in devices:
                results['skipped'] += 1
                results['details'].append({
                    'vulnerability_id': vuln.get('id'),
                    'status': 'skipped',
                    'reason': 'Device not found'
                })
                continue
                
            device = devices[device_id]
            
            # Skip non-auto-remediable vulnerabilities
            if not vuln.get('auto_remediable', False):
                results['skipped'] += 1
                results['details'].append({
                    'vulnerability_id': vuln.get('id'),
                    'status': 'skipped',
                    'reason': 'Not auto-remediable'
                })
                continue
                
            # Attempt remediation
            remediation_result = self.remediate_vulnerability(vuln, device)
            
            if remediation_result.get('success', False):
                results['successful'] += 1
                results['details'].append({
                    'vulnerability_id': vuln.get('id'),
                    'status': 'success',
                    'result': remediation_result
                })
            else:
                results['failed'] += 1
                results['details'].append({
                    'vulnerability_id': vuln.get('id'),
                    'status': 'failed',
                    'result': remediation_result
                })
                
        return results


# Create a global remediator instance
remediator = VulnerabilityRemediator()

def remediate_vulnerability(vulnerability, device=None):
    """
    Function to remediate a single vulnerability
    
    Args:
        vulnerability (dict): Vulnerability information
        device (dict, optional): Device information, if not included in vulnerability
        
    Returns:
        dict: Remediation results
    """
    if device is None and 'device' in vulnerability:
        device = vulnerability['device']
        
    if device is None:
        return {
            'success': False,
            'message': 'Device information is required for remediation'
        }
        
    return remediator.remediate_vulnerability(vulnerability, device)

def batch_remediate_vulnerabilities(vulnerabilities, devices=None):
    """
    Function to remediate multiple vulnerabilities
    
    Args:
        vulnerabilities (list): List of vulnerability objects
        devices (dict, optional): Dictionary of device objects by ID
        
    Returns:
        dict: Batch remediation results
    """
    if devices is None:
        # Extract devices from vulnerabilities
        devices = {}
        for vuln in vulnerabilities:
            if 'device' in vuln:
                device = vuln['device']
                devices[device.get('id')] = device
                
    return remediator.batch_remediate(vulnerabilities, devices)

def get_manual_remediation_steps(vulnerability_type):
    """
    Get detailed manual remediation steps for a vulnerability type
    
    Args:
        vulnerability_type (str): Type of vulnerability
        
    Returns:
        list: List of manual remediation steps
    """
    # These would typically be stored in a database or knowledge base
    remediation_steps = {
        'default_credentials': [
            'Log in to the device administration panel using the current credentials.',
            'Navigate to the user/password settings section.',
            'Change the default password to a strong, unique password.',
            'Consider enabling two-factor authentication if available.',
            'Update your password manager or secure documentation with the new credentials.'
        ],
        'weak_password': [
            'Log in to the device administration panel using the current credentials.',
            'Navigate to the user/password settings section.',
            'Change the current password to a strong, unique password (at least 12 characters with mixed case, numbers, and symbols).',
            'Consider enabling two-factor authentication if available.',
            'Update your password manager or secure documentation with the new credentials.'
        ],
        'outdated_firmware': [
            'Visit the manufacturer\'s website to download the latest firmware.',
            'Verify the integrity of the downloaded firmware using checksum validation.',
            'Back up the device configuration if possible.',
            'Follow the manufacturer instructions to install the firmware update.',
            'After updating, verify the new firmware version and restore any configurations if needed.'
        ],
        'open_ports': [
            'Log in to the device administration panel.',
            'Navigate to the network or service settings.',
            'Identify and disable unnecessary services (Telnet, FTP, SNMP, etc.).',
            'For required services, restrict access using firewall rules if available.',
            'Save settings and restart the device if required.',
            'Verify ports are closed using a port scanner.'
        ],
        'insecure_http': [
            'Log in to the device administration panel.',
            'Navigate to the web server or network settings.',
            'Enable HTTPS and configure a valid SSL certificate.',
            'Disable plain HTTP access or configure automatic redirection to HTTPS.',
            'Save settings and verify that you can only access the interface via HTTPS.'
        ],
        'weak_encryption': [
            'Log in to the device administration panel.',
            'Navigate to security or encryption settings.',
            'Disable weak encryption protocols (TLS 1.0/1.1, SSLv3, etc.).',
            'Enable strong encryption protocols (TLS 1.2/1.3).',
            'Update cipher suite preferences to prioritize strong ciphers.',
            'Save settings and restart services if required.'
        ],
        'wifi_security': [
            'Log in to the device administration panel.',
            'Navigate to the WiFi or wireless settings.',
            'Disable WEP and WPA (if used) and enable WPA2 or WPA3.',
            'Update the WiFi passphrase to a strong, complex one (>14 characters with mixed case, numbers, symbols).',
            'Enable MAC address filtering if available.',
            'Disable WPS (WiFi Protected Setup) if available.',
            'Save settings and reconnect devices to the network with the new security settings.'
        ]
    }
    
    # Find the closest matching vulnerability type
    for key in remediation_steps:
        if key in vulnerability_type.lower():
            return remediation_steps[key]
            
    # Default generic steps
    return [
        'Review the vulnerability details carefully.',
        'Consult the device manufacturer\'s documentation for security best practices.',
        'Implement the recommended security controls to address the vulnerability.',
        'After remediation, re-scan the device to verify the vulnerability has been fixed.'
    ]